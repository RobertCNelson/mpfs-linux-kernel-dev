From 5760d50afb36624eb8f2009be84ae9c31b3c8fb4 Mon Sep 17 00:00:00 2001
From: Daire McNamara <daire.mcnamara@microchip.com>
Date: Wed, 21 Jul 2021 06:34:52 +0100
Subject: [PATCH 42/93] uio: add microchip can, dma, pdma drivers

Signed-off-by: Lewis Hanly <lewis.hanly@microchip.com>
---
 drivers/uio/Kconfig              |  19 ++
 drivers/uio/Makefile             |   3 +
 drivers/uio/uio-microchip-can.c  | 202 +++++++++++++++++++++
 drivers/uio/uio-microchip-pdma.c | 297 +++++++++++++++++++++++++++++++
 drivers/uio/uio-microsemi-dma.c  | 182 +++++++++++++++++++
 5 files changed, 703 insertions(+)
 create mode 100644 drivers/uio/uio-microchip-can.c
 create mode 100644 drivers/uio/uio-microchip-pdma.c
 create mode 100644 drivers/uio/uio-microsemi-dma.c

diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 202ee81cfc2b..d35e50c1a145 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -165,4 +165,23 @@ config UIO_HV_GENERIC
 	  to network and storage devices from userspace.
 
 	  If you compile this as a module, it will be called uio_hv_generic.
+
+config UIO_MICROCHIP_CAN
+	tristate "Generic driver for Microchip CAN"
+	depends on UIO
+	help
+	  Userspace I/O interface for the Microchip CAN device.
+
+config UIO_MICROCHIP_PDMA
+	tristate "Generic driver for PolarFire SoC PDMA"
+	depends on UIO
+	help
+	  Userspace I/O interface for the PolarFire SoC PDMA.
+
+config UIO_MICROSEMI_DMA
+	tristate "Generic driver for Microsemi Fabric DMA controller"
+	depends on UIO
+	help
+	  Userspace I/O interface for the Microsemi Fabric DMA controller.
+
 endif
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index c285dd2a4539..e6a6266c2c5b 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -11,3 +11,6 @@ obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
 obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
 obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
 obj-$(CONFIG_UIO_HV_GENERIC)	+= uio_hv_generic.o
+obj-$(CONFIG_UIO_MICROCHIP_CAN)	+= uio-microchip-can.o
+obj-$(CONFIG_UIO_MICROCHIP_PDMA) += uio-microchip-pdma.o
+obj-$(CONFIG_UIO_MICROSEMI_DMA)	+= uio-microsemi-dma.o
diff --git a/drivers/uio/uio-microchip-can.c b/drivers/uio/uio-microchip-can.c
new file mode 100644
index 000000000000..29ad0ff696c5
--- /dev/null
+++ b/drivers/uio/uio-microchip-can.c
@@ -0,0 +1,202 @@
+/*
+ * MSS CAN UIO driver (uio_mss_can)
+ *
+ * This driver exports interrupts and MSS CAN register space
+ * to user space for applications interacting with MSS CAN
+ *
+ * Copyright (C) 2018-19 Microchip Incorporated - http://www.microchip.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/genalloc.h>
+
+#define DRV_NAME "mss-can-uio"
+#define DRV_VERSION "0.1"
+
+#define CAN_INT_ENABLE (4)
+#define CAN_INT_STATUS (0)
+
+#define MAX_MSS_CAN_EVT	1
+
+struct uio_mss_can_dev {
+	struct uio_info *info;
+	struct clk *mss_can_clk;
+	void __iomem *mss_can_io_vaddr;
+	int irq;
+	unsigned int pintc_base;
+};
+
+static irqreturn_t mss_can_handler(int irq, struct uio_info *info)
+{
+	struct uio_mss_can_dev *dev_info = info->priv;
+	int val;
+	void __iomem *base = dev_info->mss_can_io_vaddr + dev_info->pintc_base;
+	void __iomem *intren_reg = base + CAN_INT_ENABLE;
+	void __iomem *intrstat_reg = base + CAN_INT_STATUS;
+
+	val = ioread32(intren_reg);
+	/* Is interrupt enabled and active ? */
+	if (!(val & 0xffff) && (ioread32(intrstat_reg) & 0xffff))
+		return IRQ_NONE;
+	return IRQ_HANDLED;
+}
+
+static void mss_can_cleanup(struct device *dev,
+		struct uio_mss_can_dev *dev_info)
+{
+	int cnt;
+	struct uio_info *p = dev_info->info;
+
+	for (cnt = 0; cnt < MAX_MSS_CAN_EVT; cnt++, p++) {
+		uio_unregister_device(p);
+		kfree(p->name);
+	}
+	iounmap(dev_info->mss_can_io_vaddr);
+	kfree(dev_info->info);
+	clk_disable(dev_info->mss_can_clk);
+	clk_put(dev_info->mss_can_clk);
+	kfree(dev_info);
+}
+
+static int mss_can_probe(struct platform_device *pdev)
+{
+	struct uio_info *p;
+	struct uio_mss_can_dev *dev_info;
+	struct resource *regs_mss_can_io;
+	struct device *dev = &pdev->dev;
+	int ret = -ENODEV, cnt = 0, len;
+	/* struct uio_mss_can_pdata *pdata = dev_get_platdata(dev); TODO */
+
+	dev_info(dev, "Running Probe\n");
+
+	dev_info = kzalloc(sizeof(struct uio_mss_can_dev), GFP_KERNEL);
+	if (!dev_info)
+		return -ENOMEM;
+
+	dev_info->info = kzalloc(sizeof(*p) * MAX_MSS_CAN_EVT, GFP_KERNEL);
+	if (!dev_info->info) {
+		kfree(dev_info);
+		return -ENOMEM;
+	}
+
+	/* Power on PRU in case its not done as part of boot-loader */
+	dev_info->mss_can_clk = devm_clk_get(dev, NULL);
+	if ((!dev_info->mss_can_clk) || (IS_ERR(dev_info->mss_can_clk))) {
+		dev_err(dev, "Failed to get clock\n");
+		ret = PTR_ERR(dev_info->mss_can_clk);
+		kfree(dev_info->info);
+		kfree(dev_info);
+		return ret;
+	} else {
+		ret = clk_prepare_enable(dev_info->mss_can_clk);
+		if (ret) {
+			dev_err(dev, "Failed to enable clock\n");
+			clk_put(dev_info->mss_can_clk);
+			kfree(dev_info->info);
+			kfree(dev_info);
+			return ret;
+		}
+	}
+	devm_add_action_or_reset(dev, (void (*) (void *))clk_disable_unprepare, dev_info->mss_can_clk);
+
+	regs_mss_can_io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs_mss_can_io) {
+		dev_err(dev, "No MSS CAN I/O resource specified\n");
+		goto out_free;
+	}
+
+	if (!regs_mss_can_io->start) {
+		dev_err(dev, "Invalid memory resource\n");
+		goto out_free;
+	}
+
+	len = resource_size(regs_mss_can_io);
+	dev_info->mss_can_io_vaddr = ioremap(regs_mss_can_io->start, len);
+	if (!dev_info->mss_can_io_vaddr) {
+		dev_err(dev, "Can't remap MSS CAN I/O  address range\n");
+		goto out_free;
+	}
+
+	dev_info->irq = platform_get_irq(pdev, 0);
+
+	p = dev_info->info;
+
+	p->mem[0].addr = regs_mss_can_io->start;
+	p->mem[0].size = resource_size(regs_mss_can_io);
+	p->mem[0].memtype = UIO_MEM_PHYS;
+
+	p->mem[1].size = 0;
+
+	p->name = kasprintf(GFP_KERNEL, "mss_can%d", cnt);
+	p->version = DRV_VERSION;
+
+	/* Register MSS CAN IRQ lines */
+	p->irq = dev_info->irq;
+	p->irq_flags = IRQF_SHARED;
+	p->handler = mss_can_handler;
+	p->priv = dev_info;
+
+	ret = uio_register_device(dev, p);
+	if (ret < 0)
+		goto out_free;
+
+	platform_set_drvdata(pdev, dev_info);
+	return 0;
+
+out_free:
+	mss_can_cleanup(dev, dev_info);
+	return ret;
+}
+
+static int mss_can_remove(struct platform_device *dev)
+{
+	struct uio_mss_can_dev *dev_info = platform_get_drvdata(dev);
+
+	mss_can_cleanup(&dev->dev, dev_info);
+	return 0;
+}
+
+#define MICROCHIP_CAN_PM_OPS (NULL)
+
+#if defined(CONFIG_OF)
+static const struct of_device_id mss_can_dt_ids[] = {
+	{ .compatible = "microchip,mpfs-can-uio" },
+	{ /*sentinel */ }
+};
+#endif
+
+static struct platform_driver mss_can_driver = {
+	.probe = mss_can_probe,
+	.remove = mss_can_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = MICROCHIP_CAN_PM_OPS,
+		.of_match_table = of_match_ptr(mss_can_dt_ids),
+		.owner = THIS_MODULE,
+		   },
+};
+
+module_platform_driver(mss_can_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Daire McNamara <daire.mcnamara@microchip.com>");
diff --git a/drivers/uio/uio-microchip-pdma.c b/drivers/uio/uio-microchip-pdma.c
new file mode 100644
index 000000000000..8169403eb1b4
--- /dev/null
+++ b/drivers/uio/uio-microchip-pdma.c
@@ -0,0 +1,297 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * This driver exports interrupts and PDMA register space
+ * to user space for applications interacting with PDMA
+ *
+ * Copyright (C) 2021 Microchip Incorporated - http://www.microchip.com/
+ *
+ * Author: Daire McNamara <daire.mcnamara@microchip.com>
+ */
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include <linux/io.h>
+#include <linux/dma-mapping.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/genalloc.h>
+
+#define DRV_NAME "pdma-uio"
+#define DRV_VERSION "0.1"
+
+/* Register Offset */
+#define PDMA_CTRL					0x000
+#define PDMA_XFER_TYPE					0x004
+#define PDMA_XFER_SIZE					0x008
+#define PDMA_DST_ADDR					0x010
+#define PDMA_SRC_ADDR					0x018
+#define PDMA_ACT_TYPE					0x104 /* Read-only */
+#define PDMA_REMAINING_BYTE				0x108 /* Read-only */
+#define PDMA_CUR_DST_ADDR				0x110 /* Read-only*/
+#define PDMA_CUR_SRC_ADDR				0x118 /* Read-only*/
+
+/* CTRL */
+
+#define PDMA_DONE_STATUS_MASK	GENMASK(30, 30)
+#define PDMA_ERR_STATUS_MASK	GENMASK(31, 31)
+
+#define PDMA_NR_CH	(4)
+
+#define PDMA_CHAN_OFFSET				0x1000
+
+#define PDMA_REG_BASE(ch)	(dev_info->base + (PDMA_CHAN_OFFSET * (ch)))
+
+struct pdma_regs {
+	/* read-write regs */
+	void __iomem *ctrl;		/* 4 bytes */
+
+	void __iomem *xfer_type;	/* 4 bytes */
+	void __iomem *xfer_size;	/* 8 bytes */
+	void __iomem *dst_addr;		/* 8 bytes */
+	void __iomem *src_addr;		/* 8 bytes */
+
+	/* read-only */
+	void __iomem *act_type;		/* 4 bytes */
+	void __iomem *residue;		/* 8 bytes */
+	void __iomem *cur_dst_addr;	/* 8 bytes */
+	void __iomem *cur_src_addr;	/* 8 bytes */
+};
+
+struct uio_pdma_chan {
+	int txirq;
+	int errirq;
+	struct pdma_regs regs;
+};
+
+struct uio_pdma {
+	struct uio_info *uio_info[PDMA_NR_CH * 2];
+	void __iomem *base;
+	struct uio_pdma_chan chans[PDMA_NR_CH];
+	unsigned int pintc_base;
+};
+
+static irqreturn_t uio_pdma_done_isr(int irq, struct uio_info *uio_info)
+{
+	struct uio_pdma_chan *chan = uio_info->priv;
+	struct pdma_regs *regs = &chan->regs;
+	u32 val;
+
+	val = readl(regs->ctrl) & PDMA_DONE_STATUS_MASK;
+	writel(val & ~PDMA_DONE_STATUS_MASK, regs->ctrl);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t uio_pdma_err_isr(int irq, struct uio_info *uio_info)
+{
+	struct uio_pdma_chan *chan = uio_info->priv;
+	struct pdma_regs *regs = &chan->regs;
+	u32 val;
+
+	val = readl(regs->ctrl) & PDMA_ERR_STATUS_MASK;
+	writel(val & ~PDMA_ERR_STATUS_MASK, regs->ctrl);
+
+	return IRQ_HANDLED;
+}
+
+static int uio_pdma_irq_init(struct platform_device *pdev,
+			     struct uio_pdma *dev_info)
+{
+	int irq, i;
+	struct uio_pdma_chan *chan;
+
+	for (i = 0; i < PDMA_NR_CH; i++) {
+		chan = &dev_info->chans[i];
+
+		irq = platform_get_irq(pdev, i * 2);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "ch(%d) Can't get done irq.\n", i);
+			return -EINVAL;
+		}
+
+		chan->txirq = irq;
+
+		irq = platform_get_irq(pdev, (i * 2) + 1);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "ch(%d) Can't get err irq.\n", i);
+			return -EINVAL;
+		}
+
+		chan->errirq = irq;
+
+		chan->regs.ctrl =
+			PDMA_REG_BASE(i) + PDMA_CTRL;
+		chan->regs.xfer_type =
+			PDMA_REG_BASE(i) + PDMA_XFER_TYPE;
+		chan->regs.xfer_size =
+			PDMA_REG_BASE(i) + PDMA_XFER_SIZE;
+		chan->regs.dst_addr =
+			PDMA_REG_BASE(i) + PDMA_DST_ADDR;
+		chan->regs.src_addr =
+			PDMA_REG_BASE(i) + PDMA_SRC_ADDR;
+		chan->regs.act_type =
+			PDMA_REG_BASE(i) + PDMA_ACT_TYPE;
+		chan->regs.residue =
+			PDMA_REG_BASE(i) + PDMA_REMAINING_BYTE;
+		chan->regs.cur_dst_addr =
+			PDMA_REG_BASE(i) + PDMA_CUR_DST_ADDR;
+		chan->regs.cur_src_addr =
+			PDMA_REG_BASE(i) + PDMA_CUR_SRC_ADDR;
+	}
+
+	return 0;
+}
+
+static void pdma_cleanup(struct device *dev, struct uio_pdma *dev_info)
+{
+	int cnt;
+	struct uio_info *uio_info;
+
+	for (cnt = 0; cnt < PDMA_NR_CH * 2; cnt++) {
+		uio_info = dev_info->uio_info[cnt];
+		uio_unregister_device(uio_info);
+		kfree(uio_info->name);
+		kfree(uio_info);
+	}
+	iounmap(dev_info->base);
+	kfree(dev_info);
+}
+
+static int pdma_probe(struct platform_device *pdev)
+{
+	struct uio_info *uio_info;
+	struct uio_pdma *dev_info;
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+	int ret = -ENODEV, cnt = 0, len;
+	int i;
+
+	dev_info(dev, "Running Probe\n");
+
+	dev_info = kzalloc(sizeof(*dev_info), GFP_KERNEL);
+	if (!dev_info)
+		return -ENOMEM;
+
+	for (i = 0; i < PDMA_NR_CH * 2; i++) {
+		dev_info->uio_info[i] = kzalloc(sizeof(*dev_info->uio_info[i]),
+						GFP_KERNEL);
+
+		if (!dev_info->uio_info[i]) {
+			for (cnt = 0; cnt < i; cnt++)
+				kfree(dev_info->uio_info[cnt]);
+			kfree(dev_info);
+			return -ENOMEM;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "No PDMA I/O resource specified\n");
+		goto out_free;
+	}
+
+	len = resource_size(res);
+	dev_info->base = ioremap(res->start, len);
+	if (!dev_info->base) {
+		dev_err(dev, "Can't remap PDMA I/O  address range\n");
+		goto out_free;
+	}
+
+	ret = uio_pdma_irq_init(pdev, dev_info);
+	if (ret) {
+		dev_err(dev, "Can't parse IRQs for PDMA\n");
+		goto out_free;
+	}
+
+	for (cnt = 0; cnt < PDMA_NR_CH; cnt++) {
+		uio_info = dev_info->uio_info[cnt * 2];
+
+		uio_info->mem[0].addr = res->start;
+		uio_info->mem[0].size = len;
+		uio_info->mem[0].memtype = UIO_MEM_PHYS;
+
+		uio_info->mem[1].size = 0;
+
+		uio_info->name = kasprintf(GFP_KERNEL, "pdma%d", cnt);
+		uio_info->version = DRV_VERSION;
+
+		/* Register PDMA txdone IRQ line */
+		uio_info->irq = dev_info->chans[cnt].txirq;
+		uio_info->irq_flags = IRQF_SHARED;
+		uio_info->handler = uio_pdma_done_isr;
+		uio_info->priv = &dev_info->chans[cnt];
+
+		ret = uio_register_device(dev, uio_info);
+		if (ret < 0)
+			goto out_free;
+
+		uio_info = dev_info->uio_info[(cnt * 2) + 1];
+
+		uio_info->mem[0].addr = res->start;
+		uio_info->mem[0].size = len;
+		uio_info->mem[0].memtype = UIO_MEM_PHYS;
+
+		uio_info->mem[1].size = 0;
+
+		uio_info->name = kasprintf(GFP_KERNEL, "pdmaerr%d", cnt);
+		uio_info->version = DRV_VERSION;
+
+		/* Register PDMA err IRQ line */
+		uio_info->irq = dev_info->chans[cnt].errirq;
+		uio_info->irq_flags = IRQF_SHARED;
+		uio_info->handler = uio_pdma_err_isr;
+		uio_info->priv = &dev_info->chans[cnt];
+
+		ret = uio_register_device(dev, uio_info);
+		if (ret < 0)
+			goto out_free;
+	}
+
+	platform_set_drvdata(pdev, dev_info);
+
+	dev_info(dev, "Registered 8 devices\n");
+
+	return 0;
+
+out_free:
+	pdma_cleanup(dev, dev_info);
+	return ret;
+}
+
+static int pdma_remove(struct platform_device *dev)
+{
+	struct uio_pdma *dev_info = platform_get_drvdata(dev);
+
+	pdma_cleanup(&dev->dev, dev_info);
+	return 0;
+}
+
+#define MICROCHIP_PDMA_PM_OPS (NULL)
+
+#if defined(CONFIG_OF)
+static const struct of_device_id pdma_dt_ids[] = {
+	{ .compatible = "microchip,mpfs-pdma-uio" },
+	{ /*sentinel */ }
+};
+#endif
+
+static struct platform_driver pdma_driver = {
+	.probe = pdma_probe,
+	.remove = pdma_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = MICROCHIP_PDMA_PM_OPS,
+		.of_match_table = of_match_ptr(pdma_dt_ids),
+		.owner = THIS_MODULE,
+		   },
+};
+
+module_platform_driver(pdma_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Daire McNamara <daire.mcnamara@microchip.com>");
diff --git a/drivers/uio/uio-microsemi-dma.c b/drivers/uio/uio-microsemi-dma.c
new file mode 100644
index 000000000000..6fb95b8763a9
--- /dev/null
+++ b/drivers/uio/uio-microsemi-dma.c
@@ -0,0 +1,182 @@
+/*
+ * MSS DMA UIO driver (uio_mss_dma)
+ *
+ * This driver exports interrupts and MSS DMA register space
+ * to user space for applications interacting with MSS DMA
+ *
+ * Copyright (C) 2018-19 Microchip Incorporated - http://www.microchip.com/
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation version 2.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/uio_driver.h>
+#include <linux/io.h>
+#include <linux/clk.h>
+#include <linux/dma-mapping.h>
+#include <linux/sizes.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/genalloc.h>
+
+#define DRV_NAME "mss-dma-uio"
+#define DRV_VERSION "0.1"
+
+#define MAX_MSS_DMA_EVT	1
+#define DMA_INT_CLR  0x18
+#define DMA_INT_STA  0x10
+#define DMA_INT_OCCURED 0x01
+
+struct uio_mss_dma_dev {
+	struct uio_info *info;
+	struct clk *mss_dma_clk;
+	void __iomem *mss_dma_io_vaddr;
+	int irq;
+	unsigned int pintc_base;
+};
+
+static irqreturn_t mss_dma_handler(int irq, struct uio_info *info)
+{
+	struct uio_mss_dma_dev *dev_info = info->priv;
+	void __iomem *base = dev_info->mss_dma_io_vaddr;
+	void __iomem *int_clear = base + (DMA_INT_CLR);
+	void __iomem *int_sta = base + (DMA_INT_STA);
+
+	if((ioread32(int_sta) & DMA_INT_OCCURED) == DMA_INT_OCCURED)
+	{
+		iowrite32(DMA_INT_OCCURED, int_clear);
+		return IRQ_HANDLED;
+	}
+
+	return IRQ_NONE;
+}
+
+static void mss_dma_cleanup(struct device *dev,
+		struct uio_mss_dma_dev *dev_info)
+{
+	int cnt;
+	struct uio_info *p = dev_info->info;
+
+	for (cnt = 0; cnt < MAX_MSS_DMA_EVT; cnt++, p++) {
+		uio_unregister_device(p);
+		kfree(p->name);
+	}
+	iounmap(dev_info->mss_dma_io_vaddr);
+	kfree(dev_info->info);
+
+	kfree(dev_info);
+}
+
+static int mss_dma_probe(struct platform_device *pdev)
+{
+	struct uio_info *p;
+	struct uio_mss_dma_dev *dev_info;
+	struct resource *regs_mss_dma_io;
+	struct device *dev = &pdev->dev;
+	int ret = -ENODEV, cnt = 0, len;
+	/* struct uio_mss_dma_pdata *pdata = dev_get_platdata(dev); TODO */
+
+	dev_info(dev, "Running Probe\n");
+
+	dev_info = kzalloc(sizeof(struct uio_mss_dma_dev), GFP_KERNEL);
+	if (!dev_info)
+		return -ENOMEM;
+
+	dev_info->info = kzalloc(sizeof(*p) * MAX_MSS_DMA_EVT, GFP_KERNEL);
+	if (!dev_info->info) {
+		kfree(dev_info);
+		return -ENOMEM;
+	}
+
+	regs_mss_dma_io = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs_mss_dma_io) {
+		dev_err(dev, "No MSS DMA I/O resource specified\n");
+		goto out_free;
+	}
+
+	if (!regs_mss_dma_io->start) {
+		dev_err(dev, "Invalid memory resource\n");
+		goto out_free;
+	}
+
+	len = resource_size(regs_mss_dma_io);
+	dev_info->mss_dma_io_vaddr = ioremap(regs_mss_dma_io->start, len);
+	if (!dev_info->mss_dma_io_vaddr) {
+		dev_err(dev, "Can't remap MSS DMA I/O  address range\n");
+		goto out_free;
+	}
+
+	dev_info->irq = platform_get_irq(pdev, 0);
+
+	p = dev_info->info;
+
+	p->mem[0].addr = regs_mss_dma_io->start;
+	p->mem[0].size = resource_size(regs_mss_dma_io);
+	p->mem[0].memtype = UIO_MEM_PHYS;
+
+	p->mem[1].size = 0;
+
+	p->name = kasprintf(GFP_KERNEL, "fpga_dma%d", cnt);
+	p->version = DRV_VERSION;
+
+	/* Register MSS DMA IRQ lines */
+	p->irq = dev_info->irq;
+	p->irq_flags = IRQF_SHARED;
+	p->handler = mss_dma_handler;
+	p->priv = dev_info;
+
+	ret = uio_register_device(dev, p);
+	if (ret < 0)
+		goto out_free;
+
+	platform_set_drvdata(pdev, dev_info);
+	return 0;
+
+out_free:
+	mss_dma_cleanup(dev, dev_info);
+	return ret;
+}
+
+static int mss_dma_remove(struct platform_device *dev)
+{
+	struct uio_mss_dma_dev *dev_info = platform_get_drvdata(dev);
+
+	mss_dma_cleanup(&dev->dev, dev_info);
+	return 0;
+}
+
+#define MICROSEMI_DMA_PM_OPS (NULL)
+
+#if defined(CONFIG_OF)
+static const struct of_device_id mss_dma_dt_ids[] = {
+	{ .compatible = "microchip,mpfs-fpga-dma-uio" },
+	{ /*sentinel */ }
+};
+#endif
+
+static struct platform_driver mss_dma_driver = {
+	.probe = mss_dma_probe,
+	.remove = mss_dma_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.pm = MICROSEMI_DMA_PM_OPS,
+		.of_match_table = of_match_ptr(mss_dma_dt_ids),
+		.owner = THIS_MODULE,
+		   },
+};
+
+module_platform_driver(mss_dma_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(DRV_VERSION);
+MODULE_AUTHOR("Vattipalli Praveen <praveen.kumar@microchip.com>");
-- 
2.30.2

