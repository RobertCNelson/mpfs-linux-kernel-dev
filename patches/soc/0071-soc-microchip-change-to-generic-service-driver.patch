From 58f0bd5bd915ba9205fddcd11808dc312c55bcb0 Mon Sep 17 00:00:00 2001
From: Conor Dooley <conor.dooley@microchip.com>
Date: Fri, 17 Sep 2021 10:50:23 +0100
Subject: [PATCH 71/93] soc: microchip: change to generic service driver

---
 .../boot/dts/microchip/microchip-mpfs.dtsi    |  24 +--
 arch/riscv/configs/icicle_kit_amp_defconfig   |   5 +-
 arch/riscv/configs/icicle_kit_defconfig       |   5 +-
 drivers/soc/microchip/Kconfig                 |  22 +-
 drivers/soc/microchip/Makefile                |   5 +-
 drivers/soc/microchip/mpfs-device-cert.c      | 144 --------------
 drivers/soc/microchip/mpfs-fpga-digest.c      | 169 ----------------
 drivers/soc/microchip/mpfs-generic-service.c  | 188 ++++++++++++++++++
 drivers/soc/microchip/mpfs-serial-number.c    | 144 --------------
 drivers/soc/microchip/mpfs-signature.c        | 177 -----------------
 10 files changed, 195 insertions(+), 688 deletions(-)
 delete mode 100644 drivers/soc/microchip/mpfs-device-cert.c
 delete mode 100644 drivers/soc/microchip/mpfs-fpga-digest.c
 create mode 100644 drivers/soc/microchip/mpfs-generic-service.c
 delete mode 100644 drivers/soc/microchip/mpfs-serial-number.c
 delete mode 100644 drivers/soc/microchip/mpfs-signature.c

diff --git a/arch/riscv/boot/dts/microchip/microchip-mpfs.dtsi b/arch/riscv/boot/dts/microchip/microchip-mpfs.dtsi
index 34f1ef49beb9..897bac37e7fb 100644
--- a/arch/riscv/boot/dts/microchip/microchip-mpfs.dtsi
+++ b/arch/riscv/boot/dts/microchip/microchip-mpfs.dtsi
@@ -525,33 +525,13 @@ hwrandom: hwrandom {
 			syscontroller = <&syscontroller>;
 		};
 
-		serialnum: serialnum {
-			compatible = "microchip,mpfs-serial-number";
+		sysserv: sysserv {
+			compatible = "microchip,mpfs-generic-service";
 			#address-cells = <1>;
 			#size-cells = <1>;
 			syscontroller = <&syscontroller>;
 		};
 
-		fpgadigest: fpgadigest {
-			compatible = "microchip,mpfs-digest";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			syscontroller = <&syscontroller>;
-		};
-
-		devicecert: cert {
-			compatible = "microchip,mpfs-device-cert";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			syscontroller = <&syscontroller>;
-		};
-
-		signature: signature {
-			compatible = "microchip,mpfs-signature";
-			#address-cells = <1>;
-			#size-cells = <1>;
-			syscontroller = <&syscontroller>;
-		};
 	};
 };
 
diff --git a/arch/riscv/configs/icicle_kit_amp_defconfig b/arch/riscv/configs/icicle_kit_amp_defconfig
index 387fcdf89c9f..5c8728934cab 100644
--- a/arch/riscv/configs/icicle_kit_amp_defconfig
+++ b/arch/riscv/configs/icicle_kit_amp_defconfig
@@ -183,10 +183,7 @@ CONFIG_BLK_DEV_NVME=y
 CONFIG_PWM=y
 CONFIG_PWM_MICROCHIP_CORE=y
 
-CONFIG_POLARFIRE_SOC_SERIAL_NUMBER=y
-CONFIG_POLARFIRE_SOC_FPGA_DIGEST=y
-CONFIG_POLARFIRE_SOC_SIGNATURE=y
-CONFIG_POLARFIRE_SOC_FPGA_CERT=y
+CONFIG_POLARFIRE_SOC_GENERIC_SERVICE=y
 
 CONFIG_U_DMA_BUF=y
 CONFIG_UIO=y
diff --git a/arch/riscv/configs/icicle_kit_defconfig b/arch/riscv/configs/icicle_kit_defconfig
index 5d4cbec122f1..e5d62add54fe 100644
--- a/arch/riscv/configs/icicle_kit_defconfig
+++ b/arch/riscv/configs/icicle_kit_defconfig
@@ -183,10 +183,7 @@ CONFIG_BLK_DEV_NVME=y
 CONFIG_PWM=y
 CONFIG_PWM_MICROCHIP_CORE=y
 
-CONFIG_POLARFIRE_SOC_SERIAL_NUMBER=y
-CONFIG_POLARFIRE_SOC_FPGA_DIGEST=y
-CONFIG_POLARFIRE_SOC_SIGNATURE=y
-CONFIG_POLARFIRE_SOC_FPGA_CERT=y
+CONFIG_POLARFIRE_SOC_GENERIC_SERVICE=y
 
 CONFIG_U_DMA_BUF=y
 CONFIG_UIO=y
diff --git a/drivers/soc/microchip/Kconfig b/drivers/soc/microchip/Kconfig
index 2f3518e4e8ec..1d3f06201c43 100644
--- a/drivers/soc/microchip/Kconfig
+++ b/drivers/soc/microchip/Kconfig
@@ -9,26 +9,8 @@ config POLARFIRE_SOC_SYS_CTRL
 
 	  If unsure, say N.
 
-config POLARFIRE_SOC_SERIAL_NUMBER
-	tristate "PFSOC Serial Number"
-	depends on POLARFIRE_SOC_SYS_CTRL
-	help
-	  This driver adds support for retrieving the PolarFire SoC's serial number via a char device.
-
-config POLARFIRE_SOC_FPGA_DIGEST
-	tristate "PFSOC FPGA Digest"
-	depends on POLARFIRE_SOC_SYS_CTRL
-	help
-	  This driver adds support for retrieving the PolarFire SoC's fpga digest via a char device.
-
-config POLARFIRE_SOC_SIGNATURE
-	tristate "PFSOC FPGA Signature"
-	depends on POLARFIRE_SOC_SYS_CTRL
-	help
-	  This driver adds support for signing a P-384 hash via a char device.
-
-config POLARFIRE_SOC_FPGA_CERT
+config POLARFIRE_SOC_GENERIC_SERVICE
 	tristate "PFSOC FPGA Device Cert"
 	depends on POLARFIRE_SOC_SYS_CTRL
 	help
-	  This driver adds support for retrieving the PolarFire SoC's device supply chain x509 certificate via a char device.
+	  This driver adds support for 
diff --git a/drivers/soc/microchip/Makefile b/drivers/soc/microchip/Makefile
index 8abde1b0ffc7..21c5cbfc8f14 100644
--- a/drivers/soc/microchip/Makefile
+++ b/drivers/soc/microchip/Makefile
@@ -1,5 +1,2 @@
 obj-$(CONFIG_POLARFIRE_SOC_SYS_CTRL)	+= mpfs-sys-controller.o
-obj-$(CONFIG_POLARFIRE_SOC_SERIAL_NUMBER) += mpfs-serial-number.o
-obj-$(CONFIG_POLARFIRE_SOC_FPGA_DIGEST)	+= mpfs-fpga-digest.o
-obj-$(CONFIG_POLARFIRE_SOC_FPGA_CERT)	+= mpfs-device-cert.o
-obj-$(CONFIG_POLARFIRE_SOC_SIGNATURE)	+= mpfs-signature.o
+obj-$(CONFIG_POLARFIRE_SOC_GENERIC_SERVICE)	+= mpfs-generic-service.o
diff --git a/drivers/soc/microchip/mpfs-device-cert.c b/drivers/soc/microchip/mpfs-device-cert.c
deleted file mode 100644
index 37898182ec1a..000000000000
--- a/drivers/soc/microchip/mpfs-device-cert.c
+++ /dev/null
@@ -1,144 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Microchip PFSoC check device cert driver
- *
- * Copyright (c) 2020 Microchip Corporation. All rights reserved.
- *
- * Author:
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <linux/of_platform.h>
-#include <soc/microchip/mpfs.h>
-
-#define MPFS_CERT_RESP_SIZE_BYTES 1024U
-
-#define CMD_OPCODE 0x3U
-#define CMD_DATA_SIZE 0U
-#define CMD_DATA NULL
-#define MBOX_OFFSET 0U
-#define RESP_OFFSET 0U
-
-static DEFINE_MUTEX(mpfs_device_cert_mutex);
-
-struct mpfs_device_cert_priv {
-	struct mpfs_sys_controller *sys_controller;
-};
-
-struct mpfs_device_cert_priv *device_cert_priv;
-
-static ssize_t mpfs_device_cert_read(struct file *filp, char __user *userbuf,
-				size_t len, loff_t *f_pos)
-{
-	u8 response_msg[MPFS_CERT_RESP_SIZE_BYTES];
-	u8 buffer[2 * MPFS_CERT_RESP_SIZE_BYTES + 3];
-	u8 *bufferp = buffer;
-	u32 i;
-
-	struct mpfs_mss_response response = {
-		.resp_status = 0U,
-		.resp_msg = (u32 *)response_msg,
-		.resp_size = MPFS_CERT_RESP_SIZE_BYTES
-	};
-	struct mpfs_mss_msg msg = { .cmd_opcode = CMD_OPCODE,
-				    .cmd_data_size = CMD_DATA_SIZE,
-				    .response = &response,
-				    .cmd_data = CMD_DATA,
-				    .mbox_offset = MBOX_OFFSET,
-				    .resp_offset = RESP_OFFSET };
-
-	int ret = mpfs_blocking_transaction(device_cert_priv->sys_controller, &msg);
-	if (ret)
-		return -EIO;
-	bufferp += sprintf(bufferp, "%02x ", response.resp_status);
-	for (i = 0; i < MPFS_CERT_RESP_SIZE_BYTES; i++)
-		bufferp += sprintf(bufferp, "%02x", response_msg[i]);
-
-	return simple_read_from_buffer(userbuf, len, f_pos, buffer,
-				       2 * MPFS_CERT_RESP_SIZE_BYTES + 3);
-}
-
-static int mpfs_device_cert_open(struct inode *inode, struct file *filp)
-{
-	if (!mutex_trylock(&mpfs_device_cert_mutex)) {
-		pr_debug("Device Busy\n");
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static int mpfs_device_cert_release(struct inode *inode, struct file *filp)
-{
-	mutex_unlock(&mpfs_device_cert_mutex);
-	return 0;
-}
-
-static const struct file_operations mpfs_device_cert_fops = {
-	.owner = THIS_MODULE,
-	.read = mpfs_device_cert_read,
-	.open = mpfs_device_cert_open,
-	.release = mpfs_device_cert_release
-};
-
-static struct miscdevice mpfs_device_cert_dev = { .minor = MISC_DYNAMIC_MINOR,
-					     .name = "mpfs_device_cert_num",
-					     .fops = &mpfs_device_cert_fops };
-
-static int mpfs_device_cert_probe(struct platform_device *pdev)
-{
-	struct device_node *sys_controller_np;
-	struct device *dev = &pdev->dev;
-
-	device_cert_priv = devm_kzalloc(dev, sizeof(*device_cert_priv), GFP_KERNEL);
-	if (!device_cert_priv)
-		return -ENOMEM;
-
-	sys_controller_np =
-		of_parse_phandle(pdev->dev.of_node, "syscontroller", 0);
-	if (!sys_controller_np) {
-		dev_err(&pdev->dev,
-			"Failed to find mpfs system controller node\n");
-		return -ENODEV;
-	}
-
-	device_cert_priv->sys_controller =
-		mpfs_sys_controller_get(sys_controller_np);
-	of_node_put(sys_controller_np);
-	if (!device_cert_priv->sys_controller)
-		return -EPROBE_DEFER;
-
-	platform_set_drvdata(pdev, device_cert_priv);
-	misc_register(&mpfs_device_cert_dev);
-	dev_info(&pdev->dev,
-		 "Successfully registered mpfs device cert driver\n");
-
-	return 0;
-}
-
-static const struct of_device_id mpfs_device_cert_of_match[] = {
-	{
-		.compatible = "microchip,polarfire-soc-device-cert",
-	},
-	{
-		.compatible = "microchip,mpfs-device-cert",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, mpfs_device_cert_of_match);
-
-static struct platform_driver mpfs_device_cert_driver = {
-	.driver = {
-	.name = "mpfs-device-cert",
-	.of_match_table = mpfs_device_cert_of_match,
-	},
-	.probe = mpfs_device_cert_probe,
-};
-module_platform_driver(mpfs_device_cert_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
-MODULE_DESCRIPTION("PFSoC device cert driver");
diff --git a/drivers/soc/microchip/mpfs-fpga-digest.c b/drivers/soc/microchip/mpfs-fpga-digest.c
deleted file mode 100644
index c3eac96f7bcb..000000000000
--- a/drivers/soc/microchip/mpfs-fpga-digest.c
+++ /dev/null
@@ -1,169 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Microchip PFSoC fpga digest driver
- *
- * Copyright (c) 2020 Microchip Corporation. All rights reserved.
- *
- * Author:
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <linux/of_platform.h>
-#include <soc/microchip/mpfs.h>
-
-#define MPFS_DIGEST_CHECK_FABRIC_OFFSET        (0U)
-#define MPFS_DIGEST_CHECK_CC_OFFSET            (1U)
-#define MPFS_DIGEST_CHECK_SNVM_OFFSET          (2U)
-#define MPFS_DIGEST_CHECK_UL_OFFSET            (3U)
-#define MPFS_DIGEST_CHECK_UKDIGEST0_OFFSET     (4U)
-#define MPFS_DIGEST_CHECK_UKDIGEST1_OFFSET     (5U)
-#define MPFS_DIGEST_CHECK_UKDIGEST2_OFFSET     (6U)
-#define MPFS_DIGEST_CHECK_UKDIGEST3_OFFSET     (7U)
-#define MPFS_DIGEST_CHECK_UKDIGEST4_OFFSET     (8U)
-#define MPFS_DIGEST_CHECK_UKDIGEST5_OFFSET     (9U)
-#define MPFS_DIGEST_CHECK_UKDIGEST6_OFFSET     (10U)
-#define MPFS_DIGEST_CHECK_UPERM_OFFSET         (11U)
-#define MPFS_DIGEST_CHECK_SYS_OFFSET           (12U)
-#define MPFS_DIGEST_CHECK_UKDIGEST7_OFFSET     (13U)
-#define MPFS_DIGEST_CHECK_ENVM_OFFSET          (14U)
-#define MPFS_DIGEST_CHECK_UKDIGEST8_OFFSET     (15U)
-#define MPFS_DIGEST_CHECK_UKDIGEST9_OFFSET     (16U)
-#define MPFS_DIGEST_CHECK_UKDIGEST10_OFFSET (17U)
-#define MPFS_DIGEST_RESP_SIZE_BYTES 576U
-#define MPFS_DIGEST_SECTION_RESP_SIZE_BYTES 32U
-
-#define CMD_OPCODE 0x04U
-#define CMD_DATA_SIZE 0U
-#define CMD_DATA NULL
-#define MBOX_OFFSET 0U
-#define RESP_OFSET 0U
-#define CMD_DATA_SIZE 0U
-
-static DEFINE_MUTEX(mpfs_digest_mutex);
-
-struct mpfs_digest_priv {
-	struct mpfs_sys_controller *sys_controller;
-};
-
-struct mpfs_digest_priv *digest_priv;
-
-static ssize_t mpfs_digest_read(struct file *filp, char __user *userbuf,
-				 size_t len, loff_t *f_pos)
-{
-	u8 response_msg[MPFS_DIGEST_RESP_SIZE_BYTES];
-	u16 buffer_length = 2 * MPFS_DIGEST_RESP_SIZE_BYTES + MPFS_DIGEST_RESP_SIZE_BYTES/32;
-	u8 buffer[buffer_length];
-	u8 *bufferp = buffer;
-	u32 i;
-
-	struct mpfs_mss_response response = {
-		.resp_status = 0U,
-		.resp_msg = (u32 *)response_msg,
-		.resp_size = MPFS_DIGEST_RESP_SIZE_BYTES
-	};
-	struct mpfs_mss_msg msg = {
-		.cmd_opcode = CMD_OPCODE,
-		.cmd_data_size = CMD_DATA_SIZE,
-		.response = &response,
-		.cmd_data = CMD_DATA,
-		.mbox_offset = MBOX_OFFSET,
-		.resp_offset = RESP_OFSET
-		};
-
-	int ret = mpfs_blocking_transaction(digest_priv->sys_controller, &msg);
-	if (ret)
-		return -EIO;
-
-	for (i = 0; i < MPFS_DIGEST_RESP_SIZE_BYTES; i++) {
-		if (i % 32 == 0 && i != 0)
-			bufferp += sprintf(bufferp, "\r\n");
-
-		bufferp += sprintf(bufferp, "%02x", response_msg[i]);
-	}
-
-	return simple_read_from_buffer(userbuf, len, f_pos, buffer, buffer_length);
-}
-
-static int mpfs_digest_open(struct inode *inode, struct file *filp)
-{
-	if (!mutex_trylock(&mpfs_digest_mutex)) {
-		pr_debug("Device Busy\n");
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static int mpfs_digest_release(struct inode *inode, struct file *filp)
-{
-	mutex_unlock(&mpfs_digest_mutex);
-	return 0;
-}
-
-static const struct file_operations mpfs_digest_fops = {
-	.owner		= THIS_MODULE,
-	.read		= mpfs_digest_read,
-	.open		= mpfs_digest_open,
-	.release	= mpfs_digest_release
-};
-
-static struct miscdevice mpfs_digest_dev = {
-	.minor		= MISC_DYNAMIC_MINOR,
-	.name		= "mpfs_fpga_digest",
-	.fops		= &mpfs_digest_fops
-};
-
-static int mpfs_digest_probe(struct platform_device *pdev)
-{
-	struct device_node *sys_controller_np;
-	struct device *dev = &pdev->dev;
-
-	digest_priv = devm_kzalloc(dev, sizeof(*digest_priv), GFP_KERNEL);
-	if (!digest_priv)
-		return -ENOMEM;
-
-	sys_controller_np =
-		of_parse_phandle(pdev->dev.of_node, "syscontroller", 0);
-	if (!sys_controller_np) {
-		dev_err(&pdev->dev, "Failed to find mpfs system controller node\n");
-		return -ENODEV;
-	}
-
-	digest_priv->sys_controller = mpfs_sys_controller_get(sys_controller_np);
-	of_node_put(sys_controller_np);
-	if (!digest_priv->sys_controller)
-		return -EPROBE_DEFER;
-
-	platform_set_drvdata(pdev, digest_priv);
-	misc_register(&mpfs_digest_dev);
-	dev_info(&pdev->dev, "Successfully registered mpfs fpga digest driver\n");
-
-	return 0;
-}
-
-static const struct of_device_id mpfs_digest_of_match[] = {
-	{
-		.compatible = "microchip,polarfire-soc-digest",
-	},
-	{
-		.compatible = "microchip,mpfs-digest",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, mpfs_digest_of_match);
-
-static struct platform_driver mpfs_digest_driver = {
-	.driver = {
-		.name = "mpfs-digest",
-		.of_match_table = mpfs_digest_of_match,
-	},
-	.probe = mpfs_digest_probe,
-};
-module_platform_driver(mpfs_digest_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
-MODULE_DESCRIPTION("PFSoC mailbox client driver");
diff --git a/drivers/soc/microchip/mpfs-generic-service.c b/drivers/soc/microchip/mpfs-generic-service.c
new file mode 100644
index 000000000000..c07dbd1b311e
--- /dev/null
+++ b/drivers/soc/microchip/mpfs-generic-service.c
@@ -0,0 +1,188 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Microchip MPFS generic_service driver
+ *
+ * Copyright (c) 2020 Microchip Corporation. All rights reserved.
+ *
+ * Author: Conor Dooley
+ *
+ */
+
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/of_platform.h>
+#include <soc/microchip/mpfs.h>
+
+static DEFINE_MUTEX(mpfs_generic_service_mutex);
+
+struct mpfs_generic_service_priv {
+	struct mpfs_sys_controller *sys_controller;
+	u8 *buffer;
+	size_t len;
+	u8 cmd_opcode;
+	u16 cmd_size_bytes;
+	u16 resp_size_bytes;
+	u16 mbox_offset;
+	u16 resp_offset;
+};
+
+struct mpfs_generic_service_priv *generic_service_priv;
+
+static ssize_t mpfs_generic_service_write(struct file *filep, const char __user *userbuf,
+				    size_t len, loff_t *offset)
+{
+	u8 *cmd_data;
+
+	if (len < 9U || len > 4096U)
+		return -1;
+
+	cmd_data = kmalloc(len, GFP_KERNEL);
+	if (!cmd_data)
+		return -ENOMEM;
+
+	int ret = copy_from_user(cmd_data, userbuf, len);
+	if (ret)
+		return -ret;
+
+	generic_service_priv->buffer = cmd_data+9;
+	generic_service_priv->len = len - 9;
+
+	generic_service_priv->cmd_opcode = *(cmd_data);
+	generic_service_priv->cmd_size_bytes = (u16)(*(cmd_data + 1)) + (u16)(*(cmd_data + 2) << 8);
+	generic_service_priv->resp_size_bytes =
+		ALIGN((u16)(*(cmd_data + 3)) + ((u16)(*(cmd_data + 4) << 8)), (4U));
+	generic_service_priv->mbox_offset = (u16)(*(cmd_data + 5)) + ((u16)(*(cmd_data + 6) << 8));
+	generic_service_priv->resp_offset = (u16)(*(cmd_data + 7)) + ((u16)(*(cmd_data + 8) << 8));
+
+	return len;
+}
+
+static ssize_t mpfs_generic_service_read(struct file *filp, char __user *userbuf,
+				     size_t len, loff_t *f_pos)
+{
+	u8 response_msg[generic_service_priv->resp_size_bytes];
+	u8 buffer[2 * generic_service_priv->resp_size_bytes + 3];
+	u8 *cmd_data = generic_service_priv->buffer;
+	u8 *bufferp = buffer;
+	u32 i;
+
+	struct mpfs_mss_response response = {
+		.resp_status = 0U,
+		.resp_msg = (u32 *)response_msg,
+		.resp_size = generic_service_priv->resp_size_bytes
+	};
+
+	struct mpfs_mss_msg msg = {
+		.cmd_opcode = generic_service_priv->cmd_opcode,
+		.cmd_data_size = generic_service_priv->cmd_size_bytes,
+		.response = &response,
+		.cmd_data = cmd_data,
+		.mbox_offset = generic_service_priv->mbox_offset,
+		.resp_offset = generic_service_priv->resp_offset
+	};
+
+	if (!generic_service_priv->buffer || generic_service_priv->len != generic_service_priv->cmd_size_bytes)
+		return -EFAULT;
+
+	int ret = mpfs_blocking_transaction(generic_service_priv->sys_controller, &msg);
+	kfree(generic_service_priv->buffer);
+
+	if (ret)
+		return -EIO;
+	bufferp += sprintf(bufferp, "%02x ", response.resp_status);
+	for (i = 0; i < generic_service_priv->resp_size_bytes; i++)
+		bufferp += sprintf(bufferp, "%02x", response_msg[i]);
+
+	return simple_read_from_buffer(
+		userbuf, len, f_pos, buffer,
+		2 * generic_service_priv->resp_size_bytes + 3);
+}
+
+static int mpfs_generic_service_open(struct inode *inode, struct file *filp)
+{
+	if (!mutex_trylock(&mpfs_generic_service_mutex)) {
+		pr_debug("Device Busy\n");
+		return -EBUSY;
+	}
+	return 0;
+}
+
+static int mpfs_generic_service_release(struct inode *inode, struct file *filp)
+{
+	mutex_unlock(&mpfs_generic_service_mutex);
+	return 0;
+}
+
+static const struct file_operations mpfs_generic_service_fops = {
+	.owner = THIS_MODULE,
+	.read = mpfs_generic_service_read,
+	.open = mpfs_generic_service_open,
+	.write = mpfs_generic_service_write,
+	.release = mpfs_generic_service_release
+};
+
+static struct miscdevice mpfs_generic_service_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mpfs_generic_service",
+	.fops = &mpfs_generic_service_fops
+};
+
+static int mpfs_generic_service_probe(struct platform_device *pdev)
+{
+	struct device_node *sys_controller_np;
+	struct device *dev = &pdev->dev;
+
+	generic_service_priv =
+		devm_kzalloc(dev, sizeof(*generic_service_priv), GFP_KERNEL);
+	if (!generic_service_priv)
+		return -ENOMEM;
+	
+	sys_controller_np =
+		of_parse_phandle(pdev->dev.of_node, "syscontroller", 0);
+	if (!sys_controller_np) {
+		dev_err(&pdev->dev,
+			"Failed to find mpfs system controller node\n");
+		return -ENODEV;
+	}
+
+	generic_service_priv->sys_controller =
+		mpfs_sys_controller_get(sys_controller_np);
+	of_node_put(sys_controller_np);
+	if (!generic_service_priv->sys_controller)
+		return -EPROBE_DEFER;
+
+	platform_set_drvdata(pdev, generic_service_priv);
+	misc_register(&mpfs_generic_service_dev);
+	dev_info(&pdev->dev,
+		 "Successfully registered mpfs generic_service driver\n");
+
+	return 0;
+}
+
+static const struct of_device_id mpfs_generic_service_of_match[] = {
+	{
+		.compatible = "microchip,polarfire-soc-generic-service",
+	},
+	{
+		.compatible = "microchip,mpfs-generic-service",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpfs_generic_service_of_match);
+
+static struct platform_driver mpfs_generic_service_driver = {
+	.driver = {
+	.name = "mpfs-generic-service",
+	.of_match_table = mpfs_generic_service_of_match,
+	},
+	.probe = mpfs_generic_service_probe,
+};
+module_platform_driver(mpfs_generic_service_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
+MODULE_DESCRIPTION("PFSoC generic_service driver");
diff --git a/drivers/soc/microchip/mpfs-serial-number.c b/drivers/soc/microchip/mpfs-serial-number.c
deleted file mode 100644
index 0eab38b4a8bd..000000000000
--- a/drivers/soc/microchip/mpfs-serial-number.c
+++ /dev/null
@@ -1,144 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Microchip PFSoC serial number driver
- *
- * Copyright (c) 2020 Microchip Corporation. All rights reserved.
- *
- * Author:
- *
- */
-
-#include <linux/fs.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/miscdevice.h>
-#include <linux/of_platform.h>
-#include <soc/microchip/mpfs.h>
-
-#define MPFS_SERIAL_RESP_SIZE_BYTES	16U
-
-#define CMD_OPCODE 0U
-#define CMD_DATA_SIZE 0U
-#define CMD_DATA NULL
-#define MBOX_OFFSET 0U
-#define RESP_OFSET 0U
-
-static DEFINE_MUTEX(mpfs_serial_mutex);
-
-struct mpfs_serial_priv {
-	struct mpfs_sys_controller *sys_controller;
-};
-
-struct mpfs_serial_priv *serial_priv;
-
-static ssize_t mpfs_serial_read(struct file *filp, char __user *userbuf, size_t len,
-			loff_t *f_pos)
-{
-	u8 response_msg[MPFS_SERIAL_RESP_SIZE_BYTES];
-	u8 buffer[2 * MPFS_SERIAL_RESP_SIZE_BYTES];
-	u8 *bufferp = buffer;
-	u32 i;
-
-	struct mpfs_mss_response response = {
-		.resp_status = 0U,
-		.resp_msg = (u32 *)response_msg,
-		.resp_size = MPFS_SERIAL_RESP_SIZE_BYTES
-	};
-	struct mpfs_mss_msg msg = {
-		.cmd_opcode = CMD_OPCODE,
-		.cmd_data_size = CMD_DATA_SIZE,
-		.response = &response,
-		.cmd_data = CMD_DATA,
-		.mbox_offset = MBOX_OFFSET,
-		.resp_offset = RESP_OFSET
-		};
-
-	int ret = mpfs_blocking_transaction(serial_priv->sys_controller, &msg);
-	if (ret)
-		return -EIO;
-
-	for (i = 0; i < MPFS_SERIAL_RESP_SIZE_BYTES; i++)
-		bufferp += sprintf(bufferp, "%02x", response_msg[i]);
-
-	return simple_read_from_buffer(userbuf, len, f_pos, buffer,
-					2 * MPFS_SERIAL_RESP_SIZE_BYTES);
-}
-
-static int mpfs_serial_open(struct inode *inode, struct file *filp)
-{
-	if (!mutex_trylock(&mpfs_serial_mutex)) {
-		pr_debug("Device Busy\n");
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static int mpfs_serial_release(struct inode *inode, struct file *filp)
-{
-	mutex_unlock(&mpfs_serial_mutex);
-	return 0;
-}
-
-static const struct file_operations mpfs_serial_fops = {
-	.owner		= THIS_MODULE,
-	.read		= mpfs_serial_read,
-	.open		= mpfs_serial_open,
-	.release	= mpfs_serial_release
-};
-
-static struct miscdevice mpfs_serial_dev = {
-	.minor		= MISC_DYNAMIC_MINOR,
-	.name		= "mpfs_serial_num",
-	.fops		= &mpfs_serial_fops
-};
-
-static int mpfs_serial_number_probe(struct platform_device *pdev)
-{
-	struct device_node *sys_controller_np;
-	struct device *dev = &pdev->dev;
-
-	serial_priv = devm_kzalloc(dev, sizeof(*serial_priv), GFP_KERNEL);
-	if (!serial_priv)
-		return -ENOMEM;
-
-	sys_controller_np = of_parse_phandle(pdev->dev.of_node, "syscontroller", 0);
-	if (!sys_controller_np) {
-		dev_err(&pdev->dev, "Failed to find mpfs system controller node\n");
-		return -ENODEV;
-	}
-
-	serial_priv->sys_controller = mpfs_sys_controller_get(sys_controller_np);
-	of_node_put(sys_controller_np);
-	if (!serial_priv->sys_controller)
-		return -EPROBE_DEFER;
-
-	platform_set_drvdata(pdev, serial_priv);
-	misc_register(&mpfs_serial_dev);
-	dev_info(&pdev->dev, "Successfully registered mpfs serial number driver\n");
-
-	return 0;
-}
-
-static const struct of_device_id mpfs_serial_number_of_match[] = {
-	{
-		.compatible = "microchip,polarfire-soc-serial-number",
-	},
-	{
-		.compatible = "microchip,mpfs-serial-number",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, mpfs_serial_number_of_match);
-
-static struct platform_driver mpfs_serial_number_driver = {
-	.driver = {
-	.name = "mpfs-serial-number",
-	.of_match_table = mpfs_serial_number_of_match,
-	},
-	.probe = mpfs_serial_number_probe,
-};
-module_platform_driver(mpfs_serial_number_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
-MODULE_DESCRIPTION("PFSoC serial number driver");
diff --git a/drivers/soc/microchip/mpfs-signature.c b/drivers/soc/microchip/mpfs-signature.c
deleted file mode 100644
index 7b6bade046c0..000000000000
--- a/drivers/soc/microchip/mpfs-signature.c
+++ /dev/null
@@ -1,177 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0
-/*
- * Microchip PFSoC check signature driver
- *
- * Copyright (c) 2020 Microchip Corporation. All rights reserved.
- *
- * Author:
- *
- */
-
-#include <linux/fs.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/device.h>
-#include <linux/uaccess.h>
-#include <linux/miscdevice.h>
-#include <linux/of_platform.h>
-#include <soc/microchip/mpfs.h>
-
-#define MPFS_SIG_RESP_SIZE_BYTES 104U //96U raw format, DER is 104
-#define MPFS_SIG_CMD_SIZE_BYTES 48U
-
-#define CMD_OPCODE 0x1AU //0x19 raw format, DER is 0x1A
-#define CMD_DATA NULL
-#define MBOX_OFFSET 0U
-#define RESP_OFFSET ALIGN((MPFS_SIG_CMD_SIZE_BYTES), (4U))
-
-static DEFINE_MUTEX(mpfs_signature_mutex);
-
-struct mpfs_signature_priv {
-	struct mpfs_sys_controller *sys_controller;
-	u8 *buffer; //of 48?
-	size_t len;
-};
-
-struct mpfs_signature_priv *signature_priv;
-
-static ssize_t mpfs_signature_write(struct file *filep, const char __user *userbuf,
-				    size_t len, loff_t *offset)
-{
-	u16 len_trun = len > MPFS_SIG_CMD_SIZE_BYTES ? MPFS_SIG_CMD_SIZE_BYTES : len;
-	u8 *cmd_data = signature_priv->buffer;
-
-	cmd_data = kmalloc(MPFS_SIG_CMD_SIZE_BYTES, GFP_KERNEL);
-	if (!cmd_data)
-		return -ENOMEM;
-
-	int ret = copy_from_user(cmd_data, userbuf, len_trun); //TODO ret val check
-	if (ret)
-		return -ret;
-	signature_priv->buffer = cmd_data;
-	signature_priv->len = len_trun;
-
-	return len;
-}
-
-static ssize_t mpfs_signature_read(struct file *filp, char __user *userbuf,
-				     size_t len, loff_t *f_pos)
-{
-	u8 response_msg[MPFS_SIG_RESP_SIZE_BYTES];
-	u8 buffer[2 * MPFS_SIG_RESP_SIZE_BYTES + 3];
-	u8 *cmd_data = signature_priv->buffer;
-	u8 *bufferp = buffer;
-	u32 i;
-
-	struct mpfs_mss_response response = {
-		.resp_status = 0U,
-		.resp_msg = (u32 *)response_msg,
-		.resp_size = MPFS_SIG_RESP_SIZE_BYTES
-	};
-	struct mpfs_mss_msg msg = { .cmd_opcode = CMD_OPCODE,
-				    .cmd_data_size = MPFS_SIG_CMD_SIZE_BYTES,
-				    .response = &response,
-				    .cmd_data = cmd_data,
-				    .mbox_offset = MBOX_OFFSET,
-				    .resp_offset = RESP_OFFSET };
-
-	if (!signature_priv->buffer || signature_priv->len != MPFS_SIG_CMD_SIZE_BYTES)
-		return -EFAULT;
-
-	int ret = mpfs_blocking_transaction(signature_priv->sys_controller, &msg);
-	kfree(signature_priv->buffer);
-
-	if (ret)
-		return -EIO;
-	bufferp += sprintf(bufferp, "%02x ", response.resp_status);
-	for (i = 0; i < MPFS_SIG_RESP_SIZE_BYTES; i++)
-		bufferp += sprintf(bufferp, "%02x", response_msg[i]);
-
-	return simple_read_from_buffer(userbuf, len, f_pos, buffer,
-				       2 * MPFS_SIG_RESP_SIZE_BYTES + 3);
-}
-
-static int mpfs_signature_open(struct inode *inode, struct file *filp)
-{
-	if (!mutex_trylock(&mpfs_signature_mutex)) {
-		pr_debug("Device Busy\n");
-		return -EBUSY;
-	}
-	return 0;
-}
-
-static int mpfs_signature_release(struct inode *inode, struct file *filp)
-{
-	mutex_unlock(&mpfs_signature_mutex);
-	return 0;
-}
-
-static const struct file_operations mpfs_signature_fops = {
-	.owner = THIS_MODULE,
-	.read = mpfs_signature_read,
-	.open = mpfs_signature_open,
-	.write = mpfs_signature_write,
-	.release = mpfs_signature_release
-};
-
-static struct miscdevice mpfs_signature_dev = {
-	.minor = MISC_DYNAMIC_MINOR,
-	.name = "mpfs_signature",
-	.fops = &mpfs_signature_fops
-};
-
-static int mpfs_signature_probe(struct platform_device *pdev)
-{
-	struct device_node *sys_controller_np;
-	struct device *dev = &pdev->dev;
-
-	signature_priv =
-		devm_kzalloc(dev, sizeof(*signature_priv), GFP_KERNEL);
-	if (!signature_priv)
-		return -ENOMEM;
-	
-	sys_controller_np =
-		of_parse_phandle(pdev->dev.of_node, "syscontroller", 0);
-	if (!sys_controller_np) {
-		dev_err(&pdev->dev,
-			"Failed to find mpfs system controller node\n");
-		return -ENODEV;
-	}
-
-	signature_priv->sys_controller =
-		mpfs_sys_controller_get(sys_controller_np);
-	of_node_put(sys_controller_np);
-	if (!signature_priv->sys_controller)
-		return -EPROBE_DEFER;
-
-	platform_set_drvdata(pdev, signature_priv);
-	misc_register(&mpfs_signature_dev);
-	dev_info(&pdev->dev,
-		 "Successfully registered mpfs signature driver\n");
-
-	return 0;
-}
-
-static const struct of_device_id mpfs_signature_of_match[] = {
-	{
-		.compatible = "microchip,polarfire-soc-signature",
-	},
-	{
-		.compatible = "microchip,mpfs-signature",
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, mpfs_signature_of_match);
-
-static struct platform_driver mpfs_signature_driver = {
-	.driver = {
-	.name = "mpfs-signature",
-	.of_match_table = mpfs_signature_of_match,
-	},
-	.probe = mpfs_signature_probe,
-};
-module_platform_driver(mpfs_signature_driver);
-
-MODULE_LICENSE("GPL v2");
-MODULE_AUTHOR("Conor Dooley <conor.dooley@microchip.com>");
-MODULE_DESCRIPTION("PFSoC signature driver");
-- 
2.30.2

