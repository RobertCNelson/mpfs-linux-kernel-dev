From 7f42ddf9d1f19cb6e67bf2d8e215f0b740eeab6e Mon Sep 17 00:00:00 2001
From: shravan kumar <shravan.chippa@microchip.com>
Date: Wed, 24 Nov 2021 12:19:51 +0530
Subject: [PATCH 81/93] i2c: fix in ack sending logic in i2c-microchip

Resolves SAR122362.

"Master reciever mode" in the were not correctly sending ACKs/NACKs
in the interrupt handler.
As a fix for this, the handling of STATUS_M_SLAR_ACK,
STATUS_M_RX_DATA_ACKED and STATUS_M_RX_DATA_NACKED were changed to
bring them in line with the bare metal driver.

Fixes: 	6c7955c3bfd ("i2c: microchip: Add driver for Microchip
PolarFire SoC")

Signed-off-by: Conor Dooley <conor.dooley@microchip.com>
Signed-off-by: shravan kumar <shravan.chippa@microchip.com>
---
 drivers/i2c/busses/i2c-microchip.c | 42 ++++++++++++++++++------------
 1 file changed, 25 insertions(+), 17 deletions(-)

diff --git a/drivers/i2c/busses/i2c-microchip.c b/drivers/i2c/busses/i2c-microchip.c
index 0d75b248b41b..02a7867b48d9 100755
--- a/drivers/i2c/busses/i2c-microchip.c
+++ b/drivers/i2c/busses/i2c-microchip.c
@@ -269,6 +269,7 @@ static irqreturn_t mpfs_i2c_handle_isr(int irq, void *_dev)
 		finish = true;
 		break;
 	case  STATUS_M_SLAW_ACK:
+	case STATUS_M_TX_DATA_ACK:
 		if (idev->msg_len > 0) {
 			mpfs_i2c_fill_tx(idev);
 		} else {
@@ -278,33 +279,43 @@ static irqreturn_t mpfs_i2c_handle_isr(int irq, void *_dev)
 		}
 		break;
 	case STATUS_M_TX_DATA_NACK:
-	case STATUS_M_RX_DATA_NACKED:
 	case STATUS_M_SLAR_NACK:
 	case STATUS_M_SLAW_NACK:
 		idev->msg_err = -ENXIO;
 		mpfs_i2c_stop(idev);
 		finish = true;
 		break;
-	case STATUS_M_TX_DATA_ACK:
-		if (idev->msg_len > 0) {
-			mpfs_i2c_fill_tx(idev);
-		} else {
-			/* On the last byte to be transmitted, send STOP */
-			mpfs_i2c_stop(idev);
-			finish = true;
-		}
-		break;
 	case STATUS_M_SLAR_ACK:
-		ctrl = readl(idev->base + MPFS_I2C_CTRL);
-		ctrl |= (1 << CTRL_AA);
-		writel(ctrl, idev->base + MPFS_I2C_CTRL);
-		if (idev->msg_len == 0) {
+		if (idev->msg_len > 1u)
+		{
+			ctrl = readl(idev->base + MPFS_I2C_CTRL);
+			ctrl |= (1 << CTRL_AA);
+			writel(ctrl, idev->base + MPFS_I2C_CTRL);
+		}
+		else if (1u == idev->msg_len)
+		{
+			ctrl = readl(idev->base + MPFS_I2C_CTRL);
+			ctrl &= ~(1 << CTRL_AA);
+			writel(ctrl, idev->base + MPFS_I2C_CTRL);
+		}
+		else {
+			ctrl = readl(idev->base + MPFS_I2C_CTRL);
+			ctrl |= (1 << CTRL_AA);
+			writel(ctrl, idev->base + MPFS_I2C_CTRL);
 			/* On the last byte to be transmitted, send STOP */
 			mpfs_i2c_stop(idev);
 			finish = true;
 		}
 		break;
 	case STATUS_M_RX_DATA_ACKED:
+		mpfs_i2c_empty_rx(idev);
+		if (idev->msg_len >= 1) {
+			ctrl = readl(idev->base + MPFS_I2C_CTRL);
+			ctrl &= ~(1 << CTRL_AA);
+			writel(ctrl, idev->base + MPFS_I2C_CTRL);
+		}
+		break;
+	case STATUS_M_RX_DATA_NACKED:
 		mpfs_i2c_empty_rx(idev);
 		if (idev->msg_len == 0) {
 			/* On the last byte to be transmitted, send STOP */
@@ -317,9 +328,6 @@ static irqreturn_t mpfs_i2c_handle_isr(int irq, void *_dev)
 	}
 
 	if (finish) {
-		ctrl = readl(idev->base + MPFS_I2C_CTRL);
-		ctrl &= ~(1 << CTRL_AA);
-		writel(ctrl, idev->base + MPFS_I2C_CTRL);
 		complete(&idev->msg_complete);
 	}
 
-- 
2.30.2

